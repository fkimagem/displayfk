# Documenta√ß√£o da Classe RadioGroup

## Vis√£o Geral

A classe `RadioGroup` √© um widget interativo que exibe um grupo de bot√µes de r√°dio onde apenas um pode estar selecionado por vez. Ele herda de `WidgetBase` e fornece funcionalidade completa para criar e gerenciar grupos de sele√ß√£o √∫nica na tela.

### Caracter√≠sticas Principais

- üîò Grupo de bot√µes de r√°dio circulares
- ‚úÖ Sele√ß√£o √∫nica (apenas um bot√£o ativo por vez)
- üé® Cores personaliz√°veis para cada bot√£o
- üìê Raio configur√°vel para todos os bot√µes
- üîî Callback para mudan√ßas de sele√ß√£o
- üëÜ Suporte a toque para sele√ß√£o
- üíæ Gerenciamento autom√°tico de mem√≥ria
- üëÅÔ∏è Pode ser mostrado/ocultado dinamicamente
- üåì Suporte a modo claro/escuro
- üîó Integra-se automaticamente com o sistema DisplayFK

---

## üìã Estruturas de Configura√ß√£o

### radio_t

Estrutura que representa um bot√£o de r√°dio individual:

```cpp
struct radio_t {
  uint16_t x;     // Coordenada X do bot√£o
  uint16_t y;     // Coordenada Y do bot√£o
  uint8_t id;     // ID √∫nico do bot√£o no grupo
  uint16_t color; // Cor do bot√£o quando selecionado
};
```

### RadioGroupConfig

Estrutura que cont√©m todos os par√¢metros de configura√ß√£o do grupo:

```cpp
struct RadioGroupConfig {
  uint8_t group;               // ID do grupo
  uint16_t radius;             // Raio de todos os bot√µes
  uint8_t amount;              // N√∫mero de bot√µes no grupo
  const radio_t* buttons;      // Array de bot√µes
  uint8_t defaultClickedId;    // ID do bot√£o selecionado por padr√£o
  functionCB_t callback;       // Fun√ß√£o callback
};
```

---

## üîß M√©todos P√∫blicos

### Construtor

```cpp
RadioGroup(uint8_t _screen)
```

Cria um novo grupo de bot√µes de r√°dio.

**Par√¢metros:**
- `_screen`: Identificador da tela (0 = primeira tela)

**Nota:** Ap√≥s criar o objeto, chame `setup()` antes de us√°-lo.

### Destrutor

```cpp
~RadioGroup()
```

Libera automaticamente a mem√≥ria alocada para os bot√µes.

### setup()

```cpp
void setup(const RadioGroupConfig& config)
```

Configura o grupo de bot√µes de r√°dio. **Este m√©todo deve ser chamado ap√≥s a cria√ß√£o do objeto.**

**Par√¢metros:**
- `config`: Estrutura `RadioGroupConfig` com as configura√ß√µes

### getSelected()

```cpp
uint16_t getSelected()
```

Retorna o ID do bot√£o atualmente selecionado.

### setSelected()

```cpp
void setSelected(uint16_t clickedId)
```

Define qual bot√£o est√° selecionado programaticamente.

**Par√¢metros:**
- `clickedId`: ID do bot√£o a selecionar

### getGroupId()

```cpp
uint16_t getGroupId()
```

Retorna o ID do grupo.

### show()

```cpp
void show()
```

Torna o grupo de bot√µes vis√≠vel.

### hide()

```cpp
void hide()
```

Oculta o grupo de bot√µes.

---

## üîí M√©todos Privados (Apenas para Refer√™ncia)

Estes m√©todos s√£o chamados internamente:

- `detectTouch()`: Detecta toque nos bot√µes
- `redraw()`: Redesenha os bot√µes
- `forceUpdate()`: For√ßa atualiza√ß√£o
- `getCallbackFunc()`: Retorna callback
- `cleanupMemory()`: Limpa mem√≥ria alocada

---

## üíª Como Usar no Arduino IDE

### üìö Passo 1: Incluir as Bibliotecas

```cpp
#include <displayfk.h>
// Incluir outras bibliotecas necess√°rias
```

### üìù Passo 2: Declarar Objetos Globais

```cpp
DisplayFK myDisplay;

// Definir bot√µes do grupo
radio_t opcoes[] = {
    {50, 100, 1, CFK_COLOR01},  // Op√ß√£o 1
    {50, 150, 2, CFK_COLOR02},  // Op√ß√£o 2
    {50, 200, 3, CFK_COLOR03}   // Op√ß√£o 3
};

// Criar RadioGroup
RadioGroup radiogroup(0);

const uint8_t qtdRadiogroup = 1;
RadioGroup *arrayRadiogroup[qtdRadiogroup] = {&radiogroup};
```

### ‚öôÔ∏è Passo 3: Configurar Display (setup)

```cpp
void setup() {
    Serial.begin(115200);
    
    // ... configura√ß√£o do display ...
    myDisplay.setDrawObject(tft);
    
    loadWidgets();
    myDisplay.loadScreen(screen0);
    myDisplay.createTask(false, 3);
}
```

### üîß Passo 4: Configurar o RadioGroup

```cpp
void loadWidgets() {
    // Configurar RadioGroup
    RadioGroupConfig configRadioGroup = {
        .group = 1,
        .radius = 15,
        .amount = 3,
        .buttons = opcoes,
        .defaultClickedId = 1,
        .callback = radiogroup_cb
    };
    radiogroup.setup(configRadioGroup);
    
    // Registrar no DisplayFK
    myDisplay.setRadiogroup(arrayRadiogroup, qtdRadiogroup);
}
```

### üîî Passo 5: Criar Fun√ß√£o de Callback

```cpp
void radiogroup_cb() {
    uint16_t selecionado = radiogroup.getSelected();
    Serial.print("Op√ß√£o selecionada: ");
    Serial.println(selecionado);
    
    // Fa√ßa algo baseado na sele√ß√£o
    switch(selecionado) {
        case 1:
            Serial.println("Op√ß√£o 1 selecionada");
            break;
        case 2:
            Serial.println("Op√ß√£o 2 selecionada");
            break;
        case 3:
            Serial.println("Op√ß√£o 3 selecionada");
            break;
    }
}
```

### üñ•Ô∏è Passo 6: Fun√ß√£o da Tela

```cpp
void screen0() {
    tft->fillScreen(CFK_WHITE);
    WidgetBase::backgroundColor = CFK_WHITE;
    
    myDisplay.drawWidgetsOnScreen(0);
}
```

### üîÑ Passo 7: Exemplo de Uso

```cpp
void loop() {
    // Ler sele√ß√£o atual
    uint16_t opcaoAtual = radiogroup.getSelected();
    
    // Alterar sele√ß√£o programaticamente
    radiogroup.setSelected(2);
    
    delay(1000);
}
```

---

## üìù Exemplo Completo

```cpp
#include <displayfk.h>

DisplayFK myDisplay;
Arduino_DataBus *bus = nullptr;
Arduino_GFX *gfx = nullptr;

// Definir op√ß√µes do grupo
radio_t opcoesTemperatura[] = {
    {80, 100, 1, CFK_RED},      // Quente
    {80, 150, 2, CFK_YELLOW},   // Morno
    {80, 200, 3, CFK_BLUE}      // Frio
};

// Criar RadioGroup
RadioGroup grupoTemperatura(0);

const uint8_t qtdRadiogroup = 1;
RadioGroup *arrayRadiogroup[qtdRadiogroup] = {&grupoTemperatura};

void setup() {
    Serial.begin(115200);
    
    // Inicializar display
    bus = new Arduino_ESP32SPI(/* ... */);
    gfx = new Arduino_ST7789(/* ... */);
    gfx->begin();
    
    myDisplay.setDrawObject(gfx);
    
    // Configurar RadioGroup
    RadioGroupConfig config = {
        .group = 1,
        .radius = 20,
        .amount = 3,
        .buttons = opcoesTemperatura,
        .defaultClickedId = 2,
        .callback = temperatura_callback
    };
    grupoTemperatura.setup(config);
    
    myDisplay.setRadiogroup(arrayRadiogroup, qtdRadiogroup);
    myDisplay.loadScreen(minhaTela);
    myDisplay.createTask(false, 3);
}

void loop() {
    // Seu c√≥digo aqui
}

void minhaTela() {
    gfx->fillScreen(CFK_WHITE);
    WidgetBase::backgroundColor = CFK_WHITE;
    myDisplay.drawWidgetsOnScreen(0);
}

void temperatura_callback() {
    uint16_t temp = grupoTemperatura.getSelected();
    Serial.print("Temperatura selecionada: ");
    Serial.println(temp);
}
```

---

## üìè Dicas e Boas Pr√°ticas

### üìê Tamanhos Recomendados
- **Pequenos:** Raio 10-15 pixels
- **M√©dios:** Raio 15-25 pixels
- **Grandes:** Raio 25-35 pixels

### üé® Cores
- Use cores diferentes para cada bot√£o
- Considere o tema claro/escuro
- Bot√£o selecionado usa a cor definida
- Bot√µes n√£o selecionados usam cor de fundo

### üîî Layout
- Espa√ßamento adequado entre bot√µes
- Alinhamento vertical ou horizontal
- Posi√ß√µes claras e organizadas
- F√°cil acesso por toque

### ‚ö° Performance
- Gerenciamento eficiente de mem√≥ria
- Redesenho apenas quando necess√°rio
- Detec√ß√£o de toque otimizada
- Callback executado apenas na mudan√ßa

### üë• Usabilidade
- Bot√µes grandes o suficiente para toque
- Feedback visual claro da sele√ß√£o
- Cores distintivas para cada op√ß√£o
- Posi√ß√µes intuitivas

### üé® Visual
- C√≠rculos com bordas definidas
- Bot√£o selecionado com c√≠rculo interno
- Cores adaptadas ao modo claro/escuro
- Renderiza√ß√£o suave e clara

### üî¢ IDs e Grupos
- IDs √∫nicos dentro do grupo
- Grupos separados para diferentes funcionalidades
- ID padr√£o sensato
- Valida√ß√£o de IDs v√°lidos

---

## üîó Heran√ßa de WidgetBase

A classe `RadioGroup` herda m√©todos de `WidgetBase`:

- `isEnabled()` / `setEnabled()`: Habilitar/desabilitar
- `isInitialized()`: Verificar configura√ß√£o
- `m_visible`: Controla visibilidade
- `m_shouldRedraw`: Flag para redesenho

---

## üîó Integra√ß√£o com DisplayFK

O `RadioGroup` integra-se com o sistema DisplayFK:

1. **Renderiza√ß√£o:** Autom√°tica com `drawWidgetsOnScreen()`
2. **Callbacks:** Executados quando sele√ß√£o muda
3. **Gerenciamento:** Controlado pelo loop principal
4. **Performance:** Redesenho eficiente
5. **Grupos:** Suporte a m√∫ltiplos grupos independentes

---

## üé® Detalhes de Renderiza√ß√£o

O RadioGroup renderiza assim:

1. **Bot√µes N√£o Selecionados:**
   - C√≠rculo de fundo com cor de fundo
   - Borda com cor de contraste
   - Sem c√≠rculo interno

2. **Bot√£o Selecionado:**
   - C√≠rculo de fundo com cor de fundo
   - Borda com cor de contraste
   - C√≠rculo interno com cor espec√≠fica do bot√£o
   - C√≠rculo interno com borda

3. **Adapta√ß√£o ao Tema:**
   - Cores ajustadas automaticamente
   - Modo claro/escuro suportado
   - Contraste adequado

---

## üîß Solu√ß√£o de Problemas

### Bot√µes n√£o aparecem
- Verifique se chamou `setup()` ap√≥s criar
- Confirme que amount > 0
- Verifique se array de bot√µes foi definido
- Chame `myDisplay.setRadiogroup()`

### Toque n√£o funciona
- Verifique se o usu√°rio tocou dentro do raio
- Confirme que o RadioGroup est√° vis√≠vel
- Verifique logs para erros
- Teste com bot√µes maiores

### Callback n√£o executa
- Verifique se callback foi configurado
- Confirme que sele√ß√£o realmente mudou
- Verifique logs para erros
- Teste com sele√ß√£o program√°tica

### Bot√µes n√£o mudam visualmente
- Verifique se m_shouldRedraw est√° sendo definido
- Confirme que redraw() est√° sendo chamado
- Verifique cores configuradas
- Teste com cores mais contrastantes

### Problemas de mem√≥ria
- Verifique se cleanupMemory() est√° sendo chamado
- Confirme que array foi alocado corretamente
- Verifique logs para erros de aloca√ß√£o
- Teste com menos bot√µes primeiro

---

## üìö Refer√™ncias

- **Classe Base:** `WidgetBase` (src/widgets/widgetbase.h)
- **DisplayFK Principal:** `DisplayFK` (src/displayfk.h)
- **Cores Padr√£o:** Definidas em displayfk.h
- **Exemplos:** examples/Embed_ESP32S3/Display_Test/

